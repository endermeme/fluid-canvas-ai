#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket
import ssl
import sys
import requests
import urllib3
import mysql.connector
from concurrent.futures import ThreadPoolExecutor
import time
import argparse
import imaplib
import poplib
import smtplib
import json
from datetime import datetime

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class PentestScanner:
    def __init__(self, target, output_file=None, timeout=5):
        self.target = target
        self.timeout = timeout
        self.output_file = output_file
        self.results = {
            "target": target,
            "scan_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "vulnerabilities": []
        }
        
    def log_result(self, service, port, vulnerability, severity, details, exploitable=False):
        # Chuyển đổi dữ liệu bytes thành string nếu cần
        if isinstance(details, bytes):
            try:
                details = details.decode('utf-8', errors='replace')
            except:
                details = str(details)
                
        result = {
            "service": service,
            "port": port,
            "vulnerability": vulnerability,
            "severity": severity,
            "details": details,
            "exploitable": exploitable
        }
        self.results["vulnerabilities"].append(result)
        status = "EXPLOITABLE" if exploitable else "DETECTED"
        severity_color = {
            "critical": "\033[91m",  # Red
            "high": "\033[91m",      # Red
            "medium": "\033[93m",    # Yellow
            "low": "\033[94m",       # Blue
            "info": "\033[92m"       # Green
        }
        reset_color = "\033[0m"
        print(f"{severity_color.get(severity.lower(), '')}{status} - {service}:{port} - {vulnerability} - {severity}{reset_color}")
        print(f"  Details: {details}")
        
    def save_results(self):
        if self.output_file:
            with open(self.output_file, 'w') as f:
                json.dump(self.results, f, indent=4)
            print(f"\nResults saved to {self.output_file}")

    def check_port_open(self, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((self.target, port))
            sock.close()
            return result == 0
        except:
            return False

    def test_http_service(self, port, use_ssl=False):
        protocol = "https" if use_ssl else "http"
        try:
            url = f"{protocol}://{self.target}:{port}/"
            resp = requests.get(url, verify=False, timeout=self.timeout)
            self.log_result("HTTP", port, "Server Info", "info", 
                           f"Status: {resp.status_code}, Server: {resp.headers.get('Server')}")
            
            # Check for robots.txt
            try:
                robots_url = f"{protocol}://{self.target}:{port}/robots.txt"
                robots_resp = requests.get(robots_url, verify=False, timeout=self.timeout)
                if robots_resp.status_code == 200:
                    self.log_result("HTTP", port, "Robots.txt found", "low", 
                                   f"Robots.txt content available", exploitable=False)
            except:
                pass
                
            # Check for /setup/ folder
            try:
                setup_url = f"{protocol}://{self.target}:{port}/setup/"
                setup_resp = requests.get(setup_url, verify=False, timeout=self.timeout)
                if setup_resp.status_code == 200:
                    self.log_result("HTTP", port, "Setup directory exposed", "medium", 
                                   f"Setup directory is accessible", exploitable=True)
            except:
                pass
            
            # Test for CSRF - Simple test only
            try:
                if "cp/javascript/main.js" in resp.text:
                    self.log_result("HTTP", port, "Potential CSRF vulnerability", "medium", 
                                   "Form without proper CSRF protection detected", exploitable=True)
            except:
                pass
                
            # Test for CVE-2014-3704 (Drupalgeddon)
            if port == 80 or port == 443 or port == 8443:
                try:
                    drupal_url = f"{protocol}://{self.target}:{port}/?q=node&destination=node"
                    drupal_resp = requests.get(drupal_url, verify=False, timeout=self.timeout)
                    if "Drupal" in drupal_resp.text:
                        self.log_result("HTTP", port, "Possible Drupal CMS (check for CVE-2014-3704)", "high", 
                                      "Drupal CMS detected, may be vulnerable to Drupalgeddon", exploitable=True)
                except:
                    pass
                    
        except Exception as e:
            self.log_result("HTTP", port, "Error testing HTTP service", "info", str(e))

    def test_smtp_service(self, port, use_ssl=False):
        try:
            if use_ssl:
                context = ssl.create_default_context()
                server = smtplib.SMTP_SSL(self.target, port, context=context, timeout=self.timeout)
            else:
                server = smtplib.SMTP(self.target, port, timeout=self.timeout)
            
            # Get banner
            banner = server.ehlo()[0]
            if banner == 250:
                resp = server.ehlo()[1].decode('utf-8')
                self.log_result("SMTP", port, "SMTP Info", "info", resp)
                
                # Test for SMTP vulnerabilities
                if "MailEnable" in resp:
                    self.log_result("SMTP", port, "MailEnable SMTP Server", "medium", 
                                  "MailEnable SMTP server might have vulnerabilities", exploitable=True)
                
                # Test for CVE-2010-4344
                if "Exim" in resp:
                    self.log_result("SMTP", port, "Potential CVE-2010-4344", "high", 
                                  "Exim SMTP server might be vulnerable to CVE-2010-4344", exploitable=True)
            
            server.quit()
        except Exception as e:
            self.log_result("SMTP", port, "Error testing SMTP service", "info", str(e))

    def test_imap_service(self, port, use_ssl=False):
        try:
            if use_ssl:
                server = imaplib.IMAP4_SSL(self.target, port)
            else:
                server = imaplib.IMAP4(self.target, port)
            
            # Get banner
            banner = server.welcome
            self.log_result("IMAP", port, "IMAP Info", "info", banner.decode('utf-8'))
            
            if "IMAP4rev1" in banner.decode('utf-8'):
                self.log_result("IMAP", port, "IMAP4rev1 Server", "low", 
                              "IMAP4rev1 server detected", exploitable=False)
                              
            server.logout()
        except Exception as e:
            self.log_result("IMAP", port, "Error testing IMAP service", "info", str(e))

    def test_pop3_service(self, port, use_ssl=False):
        try:
            if use_ssl:
                context = ssl.create_default_context()
                server = poplib.POP3_SSL(self.target, port, timeout=self.timeout)
            else:
                server = poplib.POP3(self.target, port, timeout=self.timeout)
            
            # Get banner
            banner = server.getwelcome()
            # Chuyển đổi banner từ bytes sang string nếu cần
            if isinstance(banner, bytes):
                banner = banner.decode('utf-8', errors='replace')
                
            self.log_result("POP3", port, "POP3 Info", "info", banner)
            
            if "MailEnable" in str(banner):
                self.log_result("POP3", port, "MailEnable POP3 Server", "medium", 
                              "MailEnable POP3 server might have vulnerabilities", exploitable=True)
            
            server.quit()
        except Exception as e:
            self.log_result("POP3", port, "Error testing POP3 service", "info", str(e))

    def test_mysql_service(self, port):
        try:
            # Try common username/password combinations
            common_creds = [
                ("root", ""),
                ("root", "root"),
                ("admin", "admin"),
                ("user", "password")
            ]
            
            for username, password in common_creds:
                try:
                    conn = mysql.connector.connect(
                        host=self.target,
                        port=port,
                        user=username,
                        password=password,
                        connect_timeout=self.timeout
                    )
                    
                    if conn.is_connected():
                        cursor = conn.cursor()
                        cursor.execute("SELECT VERSION()")
                        version = cursor.fetchone()[0]
                        self.log_result("MySQL", port, "MySQL Weak Credentials", "critical", 
                                      f"Connected with {username}:{password}, Version: {version}", 
                                      exploitable=True)
                        
                        # Check for CVE-2020-15180 (MariaDB 10.3.23 or earlier)
                        if "MariaDB" in version and self.compare_versions(version, "10.3.23"):
                            self.log_result("MySQL", port, "CVE-2020-15180", "critical", 
                                          f"MariaDB {version} is vulnerable to CVE-2020-15180", 
                                          exploitable=True)
                        
                        cursor.close()
                        conn.close()
                        break
                except:
                    continue
                    
            # Even if authentication fails, try to get banner
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                sock.connect((self.target, port))
                banner = sock.recv(1024)
                sock.close()
                
                if banner:
                    # Chuyển đổi banner từ bytes sang string
                    banner_str = banner.decode('utf-8', errors='replace')
                    self.log_result("MySQL", port, "MySQL Banner", "info", 
                                  f"Banner: {banner_str}", exploitable=False)
            except Exception as e:
                pass
                              
        except Exception as e:
            self.log_result("MySQL", port, "Error testing MySQL service", "info", str(e))
    
    def compare_versions(self, version_str, compare_to):
        """Compare if version_str is less than or equal to compare_to"""
        try:
            # Extract version number from string like "10.3.23-MariaDB"
            version_parts = version_str.split('-')[0].split('.')
            compare_parts = compare_to.split('.')
            
            for i in range(min(len(version_parts), len(compare_parts))):
                if int(version_parts[i]) < int(compare_parts[i]):
                    return True
                elif int(version_parts[i]) > int(compare_parts[i]):
                    return False
            
            return len(version_parts) <= len(compare_parts)
        except:
            return False

    def scan(self):
        print(f"Starting vulnerability scan against {self.target}")
        
        # Define ports to scan based on the Nmap results
        ports_to_scan = {
            80: {"service": "http", "ssl": False},
            110: {"service": "pop3", "ssl": False},
            143: {"service": "imap", "ssl": False},
            443: {"service": "http", "ssl": True},
            465: {"service": "smtp", "ssl": True},
            993: {"service": "imap", "ssl": True},
            995: {"service": "pop3", "ssl": True},
            3306: {"service": "mysql", "ssl": False},
            8443: {"service": "http", "ssl": True}
        }
        
        # Scan ports and test services
        for port, config in ports_to_scan.items():
            if self.check_port_open(port):
                service = config["service"]
                use_ssl = config["ssl"]
                
                if service == "http":
                    self.test_http_service(port, use_ssl)
                elif service == "smtp":
                    self.test_smtp_service(port, use_ssl)
                elif service == "imap":
                    self.test_imap_service(port, use_ssl)
                elif service == "pop3":
                    self.test_pop3_service(port, use_ssl)
                elif service == "mysql":
                    self.test_mysql_service(port)
        
        # Save results
        self.save_results()
        
        # Summary
        vuln_count = len(self.results["vulnerabilities"])
        exploitable_count = sum(1 for v in self.results["vulnerabilities"] if v["exploitable"])
        print(f"\nScan completed: Found {vuln_count} vulnerabilities, {exploitable_count} potentially exploitable")


def main():
    parser = argparse.ArgumentParser(description='Vulnerability Scanner')
    parser.add_argument('target', help='Target IP address or hostname')
    parser.add_argument('-o', '--output', help='Output file for results (JSON format)')
    parser.add_argument('-t', '--timeout', type=int, default=5, help='Timeout for connection attempts (default: 5)')
    
    args = parser.parse_args()
    
    scanner = PentestScanner(args.target, args.output, args.timeout)
    scanner.scan()


if __name__ == "__main__":
    print("""
    ╔═══════════════════════════════════════════════╗
    ║                                               ║
    ║        VULNERABILITY SCANNER TOOL             ║
    ║                                               ║
    ║   WARNING: Use only on authorized systems     ║
    ║                                               ║
    ╚═══════════════════════════════════════════════╝
    """)
    main() 